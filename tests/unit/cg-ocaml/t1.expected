ocaml code:
```
(* generated from imandra-ast *)
type cbor = CBOR.Simple.t

exception Cbor_error of cbor * string

let cbor_error c s = raise (Cbor_error (c, s))

module DJ_Z = struct
  type t = Z.t

  let to_yojson t = `Int (Z.to_int t)

  let of_yojson = function
    | `Int i -> Ok (Z.of_int i)
    | _ -> Error "DJ_Z.of_yojson"

  (* tag 2 (bytes) https://www.rfc-editor.org/rfc/rfc8949.html#name-bignums
*)
  let to_cbor (self : t) : cbor =
    (* small number: just use CBOR representation *)
    if Z.(abs self < of_int Stdlib.(1 lsl 62)) then
      `Int (Z.to_int self)
    else if Z.sign self >= 0 then
      `Tag (2, `Bytes (Z.to_bits self))
    else
      `Tag (3, `Bytes (Z.to_bits Z.(sub minus_one self)))

  let of_cbor (c : cbor) : t =
    match c with
    | `Int i -> Z.of_int i
    | `Tag (2, `Bytes s) ->
      (try Z.of_bits s with _ -> cbor_error c "invalid bytes for Z.t (tag
2)")
    | `Tag (3, `Bytes s) ->
      (try
         let n = Z.of_bits s in
         Z.(minus_one - n)
       with _ -> cbor_error c "invalid bytes for Z.t (tag 3)")
    | _ -> cbor_error c "expected Z.3 (tag 2 or 3)"
end

module DJ_Q = struct
  type t = Q.t

  let to_yojson t = `Float (Q.to_float t)

  let of_yojson = function
    | `Float f -> Ok (Q.of_float f)
    | _ -> Error "DJ_Q.of_yojson"

  (* tag 30, [num,den] http://peteroupc.github.io/CBOR/rational.html *)
  let to_cbor (self : t) : cbor =
    let num = Q.num self and den = Q.den self in
    `Tag (30, `Array [ DJ_Z.to_cbor num; DJ_Z.to_cbor den ])

  let of_cbor (c : cbor) : t =
    match c with
    | `Tag (30, `Array [ num; den ]) ->
      let num = DJ_Z.of_cbor num and den = DJ_Z.of_cbor den in
      Q.make num den
    | _ -> cbor_error c "expected Q.t (tag 30, [num,den])"
end

open Imandra_prelude

[@@@ocaml.warning "-39"]



type complex = {re: DJ_Z.t; im: DJ_Z.t} [@@deriving yojson]

let rec cbor_of_complex (self : complex) : cbor =
  (`Map
    [(`Text "re"), (DJ_Z.to_cbor self.re);
     (`Text "im"), (DJ_Z.to_cbor self.im)])

let rec cbor_to_complex (self : cbor) : complex =
  (match self with
   | (`Map rows) ->
     let re = let v = (Caml.List.assoc (`Text "re") rows)
              in (DJ_Z.of_cbor v)
     and im = let v = (Caml.List.assoc (`Text "im") rows)
              in (DJ_Z.of_cbor v)
     in {re; im}
   | _ -> cbor_error self "expected record")

type point =
   | Polar of DJ_Z.t * DJ_Z.t | Cartesian of complex [@@deriving yojson]

let rec cbor_of_point (self : point) : cbor =
  (match self with
   | (Polar (_x_0, _x_1)) ->
     (`Array [`Text "Polar"; `Array [DJ_Z.to_cbor _x_0; DJ_Z.to_cbor _x_1]])
   | (Cartesian _x_0) ->
     (`Array [`Text "Cartesian"; `Array [cbor_of_complex _x_0]]))

let rec cbor_to_point (self : cbor) : point =
  (match self with
   | (`Array [`Text "Polar"; `Array [_x_0; _x_1]]) ->
     (Polar ((DJ_Z.of_cbor _x_0), (DJ_Z.of_cbor _x_1)))
   | (`Array [`Text "Cartesian"; `Array [_x_0]]) ->
     (Cartesian (cbor_to_complex _x_0))
   | _ -> (cbor_error self "expected sum type"))

let c_plus =
  (fun c1 -> (fun c2 -> {re = (c1.re + c2.re); im = (c1.im + c2.im)}))

let is_cartesian =
  (fun _x ->
   (match _x with
    | (Polar (_, _)) -> false
    | (Cartesian _) -> true))

```
